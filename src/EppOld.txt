/*if (*(*curBlock)->translatedBlock == "EppBlock")
			cout << "Epp" << (*curBlock)->type << endl;
		else 
			cout << *(*curBlock)->translatedBlock << (*curBlock)->type<< endl;*/
		if((*curBlock)->type == TB_EPP) {
			
			(*curBlock)->type = TB_ORDINARY;
			Block* tmpCurBlock = *curBlock;
			EppBlock* tmp = (EppBlock*)tmpCurBlock;

			int metka = *EmptyVariablesIndexTable.begin();
			EmptyVariablesIndexTable.erase(EmptyVariablesIndexTable.begin());
			int fisrtFreeCadr = ++MaximalNumberOfBlock;
			*tmp->translatedBlock =  string("#") + to_string(metka)+ "=" +to_string(fisrtFreeCadr);


			Block* GoToBlock = new Block();
			int secondFreeCadr = ++MaximalNumberOfBlock;
			GoToBlock->translatedBlock = new string(string("GOTO ") + to_string(secondFreeCadr)) ;

			Block* NBlock = new Block();
			NBlock->translatedBlock =  new string(string("N") + to_string(fisrtFreeCadr));

			programFanuc.insert(curBlock, NBlock);
			programFanuc.insert(curBlock, GoToBlock);


			auto FisrtBlock = FindBlock(tmp->labelOne);

			Block* SecondCadrVariableWithCallbackAddress = new Block();
			SecondCadrVariableWithCallbackAddress->translatedBlock =  new string(string("#") + to_string(metka)+string("=")+ to_string(++MaximalNumberOfBlock));
			programFanuc.insert(FisrtBlock+1, SecondCadrVariableWithCallbackAddress);

			Block* SecondCadrNumber = new Block();
			SecondCadrNumber->translatedBlock =  new string(string("N")+ to_string(secondFreeCadr));
			programFanuc.insert(FisrtBlock+1, SecondCadrNumber);


			auto SecondBlock = FindBlock(tmp->labelTwo) + 1;

			Block* SecondCadrNumber1 = new Block();
			SecondCadrNumber1->translatedBlock =   new string(string("N")+ to_string(MaximalNumberOfBlock));
			programFanuc.insert(SecondBlock, SecondCadrNumber1);

			Block* SecondCadrGoToBlock = new Block();
			SecondCadrGoToBlock->translatedBlock =  new string(string("GOTO #") + to_string(metka));
			programFanuc.insert(SecondBlock, SecondCadrGoToBlock);
			return 1;
		}